pragma solidity ^0.5.7;contract Car{    address public manager; // manager for resgerst the car    struct CarType{        bytes32 c_carProducter; // producter car like BMW        bytes32 c_carType ; // the car type like F408,Q7        bytes32 c_carNumber;//car only number;        uint256 c_listingTime; // listing time    }    uint256 public carID; // car ID  for only car    mapping(uint256=>CarType) carInfo; // car info    mapping(bytes32 => uint256) carHashToID; // hash=> id    constructor() public {        manager = msg.sender;    }    modifier onlyManager(){       require(msg.sender == manager,"onlyManager can do");       _;    }     /**     * @dev register a new car .     * @param _carProducter car producter     * @param _carType car type     * @param _listingTime listing time     * @return res true register scuess,false, alread register     * @return carid is registerCar ID     */    function registerCar(bytes32 _carProducter,bytes32 _carType,bytes32 _carNumber,uint256 _listingTime) onlyManager public returns(bool res,uint256 carid){        bytes32 carHash = keccak256(abi.encodePacked(_carProducter, _carType,_carNumber, _listingTime));        res = false;        carid = carHashToID[carHash];        if(carid == 0){            //New one            CarType memory cType = CarType(_carProducter,_carType,_carNumber,_listingTime);            carID++;            carHashToID[carHash] = carID;            carInfo[carID] = cType;            carid = carID;        }    }    /**     * @dev get the car ID     * @param _carProducter car producter     * @param _carType car type     * @param _listingTime listing time     * @return carid is registerCar ID     */    function getCarID(bytes32 _carProducter,bytes32 _carType,bytes32 _carNumber,uint256 _listingTime) public view returns(uint256 carid){         bytes32 carHash = keccak256(abi.encodePacked(_carProducter, _carType,_carNumber, _listingTime));         carid = carHashToID[carHash];    }}