pragma solidity ^0.5.7;interface USER{    function isRegisterUser(address userAddr) view external returns(uint256 userID);    function getUserCar(address userAddr) view external returns(uint256[] memory cID);}interface BUYER{    function isRegisterBuyer(address _buyerAddr) view external returns(uint256 buyerID);}contract UserData {    address private owner;    address public manager;    address payable private  teamAddr;    address public carContractAddr;    address public userContractAddr;    address public buyerContractAddr;    mapping(address=>mapping(uint256=>mapping(uint256=>string))) public userCarData; // user=>carid=>time=>dataHash    mapping(address=>mapping(uint256=>mapping(uint256=>mapping(uint256=>string)))) public userNavigationData;// user=>location=>carid=>time=>dataHash    mapping(address=>mapping(uint256=>mapping(uint256=>mapping(uint256=>string)))) public userDriveData;//user=>location=>carid=>time=>dataHash;    mapping(address=>mapping(uint256=>mapping(uint256=>uint256))) public userCarDataPrice; // user=>carid=>time=>dataHash    mapping(address=>mapping(uint256=>mapping(uint256=>mapping(uint256=>uint256)))) public userNavigationDataPrice;// user=>location=>carid=>time=>dataHash    mapping(address=>mapping(uint256=>mapping(uint256=>mapping(uint256=>uint256)))) public userDriveDataPrice;//user=>location=>carid=>time=>dataHash;    constructor() public {        owner = msg.sender;    }    function setManager(address _managerAddr) public {        require(msg.sender == owner,"only owner");        manager = _managerAddr ;    }    modifier onlyManager(){       require(msg.sender == manager,"onlyManager can do");       _;    }    /**     * @dev setContractAddr .     * @param carCAddr car contract address     * @param userCAddr user contract address     */    function setContractAddr(address carCAddr, address userCAddr,address buyerCAddr) public{        uint256 size;        // solium-disable-next-line security/no-inline-assembly        assembly { size := extcodesize(carCAddr) }        require(size > 0 ,"carContractAddr not contract addr");        assembly { size := extcodesize(userCAddr) }        require(size > 0 ,"userCAddr not contract addr");        assembly { size := extcodesize(buyerCAddr) }        require(size > 0 ,"buyerCAddr not contract addr");        carContractAddr = carCAddr;        userContractAddr = userCAddr;        buyerContractAddr = buyerCAddr;    }    /**     * @dev updataCarData  .     * @param _carID car id     * @param _dataTime time of data     * @param _dataHash data ipfs hash     * @param _value price of Navigation data     */    function updataCarData(uint256 _carID,        uint256 _dataTime,        uint256 _value,        string memory _dataHash)        public    {        require(checkUserAndCar(_carID,msg.sender),"car or user not exit");        uint256[] memory  userCarList = USER(userContractAddr).getUserCar(msg.sender);        require(userCarList.length !=0,"user not car now ");        bool isRegistCar = false;        uint256 carIdLength = userCarList.length;        for(uint256 i=0; i<carIdLength; i++){            if(_carID ==userCarList[i] ){                isRegistCar = true;                break;            }        }        require(isRegistCar,"car not bound to car ");        userCarData[msg.sender][_carID][_dataTime] = _dataHash;        userCarDataPrice[msg.sender][_carID][_dataTime] = _value;    }    /**     * @dev updataNavigationData  .     * @param _carID car id     * @param _dataTime time of data     * @param _dataHash data ipfs hash     * @param _value price of Navigation data     * @param _location location info     */    function updataNavigationData(uint256 _carID,        uint256 _dataTime,        string memory _dataHash,        uint256 _value,        uint256 _location)        public    {        require(checkUserAndCar(_carID,msg.sender),"car or user not exit");        userNavigationData[msg.sender][_location][_carID][_dataTime] = _dataHash;        userNavigationDataPrice[msg.sender][_location][_carID][_dataTime] = _value;    }    /**     * @dev updataDriveData  .     * @param _carID car id     * @param _dataTime time of data     * @param _dataHash data ipfs hash     * @param _value price of Navigation data     * @param _location location info     */    function updataDriveData(uint256 _carID,        uint256 _dataTime,        string memory _dataHash,        uint256 _value,        uint256 _location)        public    {        require(checkUserAndCar(_carID,msg.sender),"car or user not exit");        userDriveData[msg.sender][_location][_carID][_dataTime] = _dataHash;        userDriveDataPrice[msg.sender][_location][_carID][_dataTime] = _value;    }    /**     * @dev buyUserDriveData  .     * @param _userAddr user address     * @param _carID car id for car info     * @param _dataTime data of updata time     */    function buyUserCarData(address payable _userAddr,uint256 _carID,uint256 _dataTime) payable public returns(string memory carHash){        require(checkUserAndCar(_carID,_userAddr),"car or user not exit");        require(checkBuyer(msg.sender),"buyer muster register");        uint256 price = userCarDataPrice[_userAddr][_carID][_dataTime];        uint256 totalPay = price + (price)/100;        require(msg.value >= totalPay,"total pay not enght");        _userAddr.transfer(price);        teamAddr.transfer((price)/100);        if(msg.value>totalPay){            msg.sender.transfer(msg.value-totalPay);        }        carHash = userCarData[_userAddr][_carID][_dataTime];    }    /**     * @dev buyUserDriveData  .     * @param _userAddr user address     * @param _carID car id for car info     * @param _dataTime data of updata time     */    function buyUserDriveData(address payable _userAddr,        uint256 _carID,        uint256 _dataTime,        uint256 _location)        payable        public        returns(string memory driveHash)    {        require(checkUserAndCar(_carID,_userAddr),"car or user not exit");        require(checkBuyer(msg.sender),"buyer muster register");        uint256 price = userDriveDataPrice[_userAddr][_location][_carID][_dataTime];        uint256 totalPay = price + (price)/100;        require(msg.value >= totalPay,"total pay not enght");        _userAddr.transfer(price);        teamAddr.transfer((price)/100);        if(msg.value>totalPay){            msg.sender.transfer(msg.value-totalPay);        }        driveHash = userDriveData[_userAddr][_location][_carID][_dataTime];    }    /**     * @dev buyUserDriveData  .     * @param _userAddr user address     * @param _carID car id for car info     * @param _dataTime data of updata time     */    function buyUserNavigationData(address payable _userAddr,        uint256 _carID,        uint256 _dataTime,        uint256 _location)        payable        public        returns(string memory NavigationHash)    {        require(checkUserAndCar(_carID,_userAddr),"car or user not exit");        require(checkBuyer(msg.sender),"buyer muster register");        uint256 price = userNavigationDataPrice[_userAddr][_location][_carID][_dataTime];        uint256 totalPay = price + (price)/100;        require(msg.value >= totalPay,"total pay not enght");        _userAddr.transfer(price);        teamAddr.transfer((price)/100);        if(msg.value>totalPay){            msg.sender.transfer(msg.value-totalPay);        }        NavigationHash = userNavigationData[_userAddr][_location][_carID][_dataTime];    }    function checkUserAndCar(uint256 _carID,address _userAddr) internal view returns(bool res){        uint256 userID =USER(userContractAddr).isRegisterUser(_userAddr);        if(_carID!=0 && userID !=0){          res = true;        }    }    function checkBuyer(address buyerAddr) internal view returns(bool res){        uint256 buyerID =BUYER(buyerContractAddr).isRegisterBuyer(buyerAddr);        if(buyerID !=0){          res = true;        }    }}